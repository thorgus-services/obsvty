---
description: "Ports & Adapters architecture for modularity"
alwaysApply: true
---
# Ports & Adapters Architecture

## Primary Ports (Driving)
✅ **Naming pattern:** `*CommandPort`, `*QueryPort`
```python
# src/obsvty/ports/trace_commands.py
from typing import Protocol
from ..core.models import TraceContext, TraceId

class TraceCommandPort(Protocol):
    """Primary port for trace processing commands"""
    def ingest_trace(self, trace: TraceContext) -> TraceId: ...
    def correlate_logs(self, trace_id: TraceId, logs: list[LogEntry]) -> None: ...
```

## Secondary Ports (Driven)
✅ **Naming pattern:** `*GatewayPort`, `*RepositoryPort`
```python
# src/obsvty/ports/storage_ports.py
from typing import Protocol, Optional
from ..core.models import TraceContext, TraceId

class TraceRepositoryPort(Protocol):
    """Secondary port for trace storage"""
    def save(self, trace: TraceContext) -> None: ...
    def find_by_id(self, trace_id: TraceId) -> Optional[TraceContext]: ...
```

## Dependency Flow (Stability Gradient)
```text
interfaces/       → depends on → application/ + adapters/
adapters/         → depends on → application/ + core/
application/      → depends on → core/
core/             → NO external dependencies
```

## Test Strategy
✅ **Primary ports:** Test directly with in-memory implementations
```python
def test_ingest_trace_creates_valid_context():
    port = InMemoryTraceCommandPort()  # ✅ No mocks
    result = port.ingest_trace(valid_trace_data)
    assert result.trace_id.startswith("obsv-")
```

✅ **Secondary ports:** Test with fakes/mocks
```python
def test_trace_repository_saves_correctly(mocker):
    mock_db = mocker.Mock()
    repo = PostgresTraceRepository(mock_db)
    repo.save(sample_trace)
    mock_db.execute.assert_called_with("INSERT INTO traces...")
```

❌ **Blocked anti-patterns:**
- `ITraceService` (vague interface name)
- Mocking primary ports in unit tests
- Implementing ports directly in `adapters/` without protocol definition